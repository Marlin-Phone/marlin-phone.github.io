---
layout: post
mathjax: true
title: "常见经典递归总结"
subtitle: "排列、组合、子集枚举"
date: 2025-08-14 12:15:00
author: "Marlin"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - 左程云算法
  - 排列
  - 组合
  - 子集枚举
---

# 常见经典递归总结

## 子集枚举

### 题目 1 [返回字符串的全部字序列](https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a)

时间复杂度：$O(n*2^n)$(子集枚举+遍历)

```cpp
bool st[20];
set<string> set_str;

void dfs(int x, string& str){
    if (x >= str.size()){
        string temp;
        for(int i = 0; i < str.size(); i++){ // 遍历子集
            if (st[i]){
                temp.push_back(str[i]);
            }
        }
        set_str.insert(temp);
        return;
    }

    st[x] = true;
    dfs(x + 1, str); // 选
    st[x] = false;
    dfs(x + 1, str); // 不选
}
vector<string> generatePermutation(string s) {
    dfs(0, s);
    vector<string> ans;
    for(auto it : set_str){
        ans.push_back(it);
    }
    return ans;
}
```

### 题目 2 [子集 II](https://leetcode.cn/problems/subsets-ii/)

时间复杂度：$O(n*2^n)$(子集枚举+遍历)

```cpp
bool stat[100]; // 存储状态
set<vector<int>> st;
void dfs(int x, vector<int> &nums) {
    if (x >= nums.size()) {
        vector<int> temp;
        for (int i = 0; i < nums.size(); i++) { // 遍历子集
            if (stat[i]) {
                temp.push_back(nums[i]);
            }
        }
        st.insert(temp);
        return;
    }
    stat[x] = true;
    dfs(x + 1, nums); // 选
    stat[x] = false;
    dfs(x + 1, nums); // 不选
}

vector<vector<int>> subsetsWithDup(vector<int> &nums) {
    vector<vector<int>> ans;
    sort(nums.begin(), nums.end());
    dfs(0, nums);
    for (auto it : st) {
        ans.push_back(it);
    }
    return ans;
}
```

## 排列

### 题目 1 [全排列](https://leetcode.cn/problems/permutations/)

```cpp
vector<vector<int>> ans;
int arr[100];
int st[100];
void dfs(int x, vector<int> &nums) {
    int n = nums.size();
    if (x >= n) {
        vector<int> temp;
        for (int i = 0; i < n; i++) {
            int idx = arr[i];
            temp.push_back(nums[idx]);
        }
        ans.push_back(temp);
        return;
    }
    for (int i = 0; i < n; i++) {
        if (st[i]) {
            continue;
        }
        st[i] = 1;
        arr[x] = i;
        dfs(x + 1, nums);
        st[i] = 0;
        arr[x] = 0;
    }
}
vector<vector<int>> permute(vector<int> &nums) {
    dfs(0, nums);
    return ans;
}
```

### 题目 2 [全排列 II](https://leetcode.cn/problems/permutations-ii/)

```cpp
set<vector<int>> set_vec;
vector<vector<int>> ans;
int arr[100];
bool st[100];

void dfs(int x, vector<int> &nums) {
    int n = nums.size();
    if (x >= n) {
        vector<int> temp;
        for (int i = 0; i < n; i++) {
            int idx = arr[i];
            temp.push_back(nums[idx]);
        }
        set_vec.insert(temp);
        return;
    }
    for (int i = 0; i < n; i++) {
        if (st[i]) {
            continue;
        }
        st[i] = true;
        arr[x] = i;
        dfs(x + 1, nums);
        st[i] = false;
        arr[x] = 0;
    }
}
vector<vector<int>> permuteUnique(vector<int> &nums) {
    dfs(0, nums);
    for (auto it : set_vec) {
        ans.push_back(it);
    }
    return ans;
}
```

## 只用递归函数逆序栈

时间复杂度：$O(n^2)$

```cpp
int bottomOut(stack<int> &stk) { // 操作：将栈底元素返回，并保持其它元素顺序不变
    int ans = stk.top();
    stk.pop();
    if (stk.empty()) {
        return ans;
    }
    int last = bottomOut(stk);
    stk.push(ans);
    return last;
}
void reverse(stack<int> &stk) { // 利用操作逆序栈
    if (stk.empty()) {
        return;
    }
    int num = bottomOut(stk);
    reverse(stk);
    stk.push(num);
}
```

## 只用递归函数排序栈

时间复杂度：$O(n^2)$

```cpp
int deep(stack<int> &stk) { // 操作：返回栈深度不改变栈状态
    if (stk.empty()) {
        return 0;
    }
    int num = stk.top();
    stk.pop();
    int deep = deep(stk) + 1;
    stk.push(num);
    return deep;
}
int max(stack<int> &stk, int deep){
    if(deep == 0){
        return INT_MIN;
    }
    int num = stk.top();
    int resMax = max(stk, deep - 1);
    stk.pop();
    int max = max(num, resMax);
    stk.push(num);
    return max;
}
int times(stack<int> &stk, int deep, int max){
    if(deep == 0){
        return 0;
    }
    int num = stk.top();
    stk.pop();
    int restTimes = times(stk, deep - 1, max);
    int times = resetTimes + (num == max ? 1 : 0);
    stk.push(num);
    return times;
}
void down(stack &stk, int deep, int max, int k){
    if(deep == 0){
        for(int i = 0; i < k; i++){
            stk.push(max);
        }
    }else{
        int num = stk.top();
        stk.pop();
        down(stk, deep - 1, max, k);
        if(num != max){
            stk.push(num);
        }
    }
}
void sortStack(stack<int> &stk) {
    int deep = deep(stk);
    int max = max(stk, deep);
    int times = times(stk, deep, max);
    down(stk, deep, max, times);
    reverse(stk);
}
```

## 汉诺塔问题

时间复杂度：$O(2^n)$

```cpp
void f(int i, int from, int to, int other){
    if(i == 1){
        cout << "移动原盘 1 从" << from << "到" << to << endl;
    }else{
        f(i - 1, from, other, to);
        cout << "移动圆盘" << i << "从" << from << "到" << to << endl;
        f(i - 1, other, to, from);
    }
}
```
