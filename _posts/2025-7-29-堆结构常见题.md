---
layout: post
mathjax: true
title: "堆结构常见题"
subtitle: ''
date: 2025-07-29 22:12:00
author: "Marlin"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - 堆结构
---


## 堆结构常见题

### 1. [合并 k 个有序链表](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6)
给定 k 个有序链表，每个链表的元素值都按升序排列，请将它们合并为一个有序链表，并返回合并后的链表。

思路：
1. 创建一个最小堆，将 k 个链表的头结点放入堆中。
2. 取出堆顶的结点，将其指向的下一个结点放入堆中。
3. 重复步骤 2，直到堆为空。
```cpp
struct Cmp{ // 自定义比较规则
        bool operator()(const struct ListNode* a, const struct ListNode* b) const {
            return a->val > b->val;
        }
    };
ListNode* mergeKLists(vector<ListNode*>& lists) {
    ListNode* head = nullptr;
    ListNode* p = nullptr;
    priority_queue<ListNode*, vector<ListNode*>, Cmp> pq;
    
    for(auto& list : lists){ // 将 k 个链表的头结点放入堆中
        if(list != nullptr){
            pq.push(list);
        } 
    }
    
    if(pq.empty()){
        return nullptr;
    }
    head = pq.top(); // 取出堆顶结点
    p = head; // 第一个取出的堆顶为head
    pq.pop();
    if(head->next != nullptr){ 
        pq.push(head->next);  // 将堆顶结点指向的下一个结点放入堆中
    }

    while(!pq.empty()){ // 重复步骤 2，直到堆为空
        ListNode* top = pq.top();
        pq.pop();
        p->next = top; // 将取出的结点链接到p后面
        p = p->next; // p指向下一个结点
        if(top->next != nullptr){ 
            pq.push(top->next);  // 将取出的结点指向的下一个结点放入堆中
        }
    }

    return head;
}
```

### 2. 线段重合
每一个线段都有start和end两个数据项，表示这条线段在X轴上从start位置开始到end位置结束。
给定一批线段，求所有重合区域中最多重合了几个线段，首尾相接的线段不算重合。
例如：线段[1,2]和线段[2.3]不重合。
线段[1,3]和线段[2,3]重合，重合区域为[2,3]。

思路：
差分做法O(max_value)最简单，见[此处](https://www.nowcoder.com/profile/42619900/codeBookDetail?submissionId=462394068)。

堆做法：
1. 